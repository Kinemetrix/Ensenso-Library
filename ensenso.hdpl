<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="13.0">
<library/>
<procedure name="ensenso_gen_3d">
<interface>
<oo>
<par name="Images" base_type="iconic" dimension="0"/>
<par name="Region" base_type="iconic" dimension="0"/>
<par name="Contours" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="CommandHandle" base_type="ctrl" dimension="0"/>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="doComputeNormals" base_type="ctrl" dimension="0"/>
<par name="doGenRegion" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Data" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*UNUSED)))))))))))))))))</c>
</body>
<docu id="ensenso_gen_3d">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="CommandHandle"/>
<parameter id="Contours"/>
<parameter id="Data"/>
<parameter id="Images"/>
<parameter id="Region"/>
<parameter id="doComputeNormals"/>
<parameter id="doGenRegion"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_get_calibration">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CalParameterNames" base_type="ctrl" dimension="0"/>
<par name="CalParameterValues" base_type="ctrl" dimension="0"/>
<par name="CalibrationJSON" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>*read calibration string if you want to write a .json file later</c>
<l>get_framegrabber_param (AcqHandle, 'Calibration', CalibrationJSON)</l>
<c></c>
<c>*NOTE THIS CALIBRATION STRING IS NOT THE SAME AS THE CALIB.JSON FILE FROM NXVIEW, WHICH CONTAINS OTHER INFO</c>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_get_calibration">
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<library lang="en_US">Ensenso</library>
<short lang="en_US">Get a calibration from the Ensenso camera</short>
<parameters>
<parameter id="AcqHandle"/>
<parameter id="CalParameterNames"/>
<parameter id="CalParameterValues"/>
<parameter id="CalibrationJSON"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_get_cam_params_rect">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CamParam0" base_type="ctrl" dimension="0"/>
<par name="CamParam1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>nxLibGetRectifiedCameraSetup (AcqHandle, CSMID)</l>
<l>get_camera_setup_param(CSMID,0,'params',CamParam0)</l>
<l>get_camera_setup_param(CSMID,1,'params',CamParam1)</l>
<l>return ()</l>
</body>
<docu id="ensenso_get_cam_params_rect">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="CamParam0"/>
<parameter id="CamParam1"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_get_pose">
<interface>
<ic>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EnsensoPose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>info_framegrabber ('Ensenso-NxLib', 'device', Information, Serial)</l>
<c></c>
<c>*read pose</c>
<l>get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/', Link)</l>
<c>*read rotation/angle</c>
<l>get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Rotation/Angle', RotationAngle)</l>
<c>*read rotation/axis</c>
<l>get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Rotation/Axis', RotationAxis)</l>
<c>*read workspace translation</c>
<l>get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Translation', WorkspaceTranslation)</l>
<c></c>
<l>tuple_regexp_replace(RotationAxis,'\\[','',Result1)</l>
<l>tuple_regexp_replace(Result1,'\\]','',Result2)</l>
<l>tuple_split(Result2,',',RotationAxisStrings)</l>
<l>tuple_number(RotationAxisStrings,RotationAxis)</l>
<c></c>
<l>tuple_regexp_replace(WorkspaceTranslation,'\\[','',Result1)</l>
<l>tuple_regexp_replace(Result1,'\\]','',Result2)</l>
<l>tuple_split(Result2,',',WorkspaceTranslationStrings)</l>
<l>tuple_number(WorkspaceTranslationStrings,WorkspaceTranslation)</l>
<c></c>
<l>axis_angle_to_quat(RotationAxis[0],RotationAxis[1],RotationAxis[2],RotationAngle,PoseQuaternion)</l>
<l>quat_to_hom_mat3d (PoseQuaternion,PoseRotationMatrix)</l>
<l>hom_mat3d_translate(PoseRotationMatrix,WorkspaceTranslation[0],WorkspaceTranslation[1],WorkspaceTranslation[2],PoseHomMat3D)</l>
<l>hom_mat3d_to_pose (PoseHomMat3D,CameraPose)</l>
<c></c>
<c></c>
<l>if(|GenParamNames| != |GenParamValues|)</l>
<l>    throw('Number of gen param names and values are not equal')</l>
<l>endif</l>
<c></c>
<l>Pose := 'world'</l>
<l>PoseOrder := 'gba'</l>
<c></c>
<l>for i:=0 to |GenParamNames|-1 by 1</l>
<l>    if(GenParamNames[i] == 'pose')</l>
<l>        if(GenParamValues[i] == 'world')</l>
<c>            </c>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'pose')</l>
<l>        if(GenParamValues[i] == 'relative')</l>
<c>            </c>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'pose_order')</l>
<l>        if(GenParamValues[i] == 'abg')</l>
<l>            PoseOrder := 'abg'</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'pose_order')</l>
<l>        if(GenParamValues[i] == 'gba')</l>
<l>            PoseOrder := 'gba'</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>if(PoseOrder == 'abg')</l>
<l>    EnsensoPose := CameraPose</l>
<l>elseif(PoseOrder == 'gba')</l>
<l>    get_pose_type(CameraPose,OrderOfTransform, OrderOfRotation, ViewOfTransform)</l>
<l>    convert_pose_type (CameraPose,OrderOfTransform, 'abg', ViewOfTransform, ABGPose)</l>
<l>    EnsensoPose := ABGPose</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_get_pose">
<abstract lang="en_US">https://github.com/zserge/jsmn/blob/master/jsmn.c

&lt;a href="https://github.com/zserge/jsmn/blob/master/jsmn.c"&gt;&lt;/a&gt;

&lt;a href="https://github.com/zserge/jsmn/blob/master/jsmn.c"&gt;JSMN Test Link&lt;/a&gt;

</abstract>
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<library lang="en_US">Ensenso</library>
<parameters>
<parameter id="EnsensoPose"/>
<parameter id="GenParamNames"/>
<parameter id="GenParamValues"/>
<parameter id="NxLibHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_get_settings">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="EnsensoParameters" base_type="ctrl" dimension="0"/>
<par name="ParameterNames" base_type="ctrl" dimension="0"/>
<par name="ParameterValues" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*read parameter string if you want to write a .json file later</c>
<l>get_framegrabber_param (AcqHandle, 'Parameters', EnsensoParameters)</l>
<c></c>
<c>*read parameters individually, separating their names and values</c>
<l>get_framegrabber_param (AcqHandle, 'available_param_names', ParameterNames)</l>
<l>tuple_sort (ParameterNames, ParameterNames)</l>
<c></c>
<c></c>
<c>* query all current parameter values:</c>
<l>ParameterValues := []</l>
<l>get_system ('do_low_error', LowErrorFlag)</l>
<l>if (LowErrorFlag == 'true')</l>
<l>  set_system ('do_low_error', 'false')</l>
<l>endif</l>
<l>dev_set_check ('~give_error')</l>
<l>dev_error_var (HalconError, 1)</l>
<l>for i := 0 to |ParameterNames| - 1 by 1</l>
<l>  get_framegrabber_param (AcqHandle, ParameterNames[i], value)</l>
<l>  tuple_concat(ParameterValues, value, ParameterValues)</l>
<l>endfor</l>
<l>dev_set_check ('give_error')</l>
<l>set_system ('do_low_error', LowErrorFlag)</l>
<l>return ()</l>
</body>
<docu id="ensenso_get_settings">
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<library lang="en_US">Ensenso</library>
<short lang="en_US">Get settings from the Ensenso camera</short>
<parameters>
<parameter id="AcqHandle"/>
<parameter id="EnsensoParameters"/>
<parameter id="ParameterNames"/>
<parameter id="ParameterValues"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_grab">
<interface>
<oo>
<par name="Images" base_type="iconic" dimension="0"/>
<par name="Regions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="ExposureGray" base_type="ctrl" dimension="0"/>
<par name="Exposure3D" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ImageOrder" base_type="ctrl" dimension="0"/>
<par name="ObjectModel3D" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*********************************************************************************</c>
<c>* ensenso_grab</c>
<c>*********************************************************************************</c>
<c>* Created by: Justin Swick</c>
<c>* Date Modified: 3/16/2017</c>
<c>*</c>
<c>* Change Log</c>
<c>* ======================================</c>
<c>* Date        Author     Description</c>
<c>* ====        ======     ===========</c>
<c>* 3/10/17     JS         Removed ensenso_grab_xyz and ensenso_grab_rect functions</c>
<c>*                        and pulled their code into ensenso_grab to enable</c>
<c>*                        faster execution times.</c>
<c>* 3/16/17     JS         New Generic Parameters:</c>
<c>*                         * 'normals'       - calculate point normals with NxLib</c>
<c>*                         * 'ortho'         - orthographic projection of point cloud</c>
<c>*                         * 'norm_win_size' - size of the sliding window to calc normals</c>
<c>*                         * 'surf_connect'  - z-axis connectivity of the ortho map</c>
<c>*                         * 'ortho_width'   - width of the orthographic projection</c>
<c>*                         * 'ortho_height'  - height of the orthographic projection</c>
<c>*                         * 'pixel_size'    - pixels / mm in the ortho projection</c>
<c>*</c>
<c>******************************************************************************************</c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>if(|GenParamNames| != |GenParamValues|)</l>
<l>    throw('Number of gen param names and values are not equal')</l>
<l>endif</l>
<c></c>
<c></c>
<c>*Default settings for gen parameters</c>
<l>GetXYZ           := false</l>
<l>GetLeftRect      := false</l>
<l>GetRightRect     := false</l>
<l>GetDisparity     := false</l>
<l>IsLightOn        := false</l>
<l>GenRegions       := false</l>
<l>ComputeNormals   := false</l>
<l>FlexView         := false</l>
<l>ComputeOrtho     := false</l>
<c></c>
<c>*compute ortho params</c>
<l>SurfaceConnectivity := 20</l>
<l>RenderPointMapSize := [2000,2000]</l>
<l>PixelSize := 1</l>
<c></c>
<c>*compute normals params</c>
<l> NormalWindowSize := 2</l>
<c>    </c>
<c>*Read gen parameters</c>
<l>for i:=0 to |GenParamNames|-1 by 1</l>
<l>    if(GenParamNames[i] == 'xyz')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GetXYZ := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'left_rect')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GetLeftRect := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'right_rect')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GetRightRect := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'disparity')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GetDisparity := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'regions')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GenRegions := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'light_on')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            IsLightOn := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'flexview')</l>
<l>        FlexView := GenParamValues[i]</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'normals')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            ComputeNormals := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'norm_win_size')</l>
<l>        NormalWindowSize := GenParamValues[i]</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'ortho')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            ComputeOrtho := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'surf_connect')</l>
<l>        SurfaceConnectivity := GenParamValues[i]</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'ortho_width')</l>
<l>        RenderPointMapSize[0] := GenParamValues[i]</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'ortho_height')</l>
<l>        RenderPointMapSize[1] := GenParamValues[i]</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'pixel_size')</l>
<l>        PixelSize := GenParamValues[i]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>*======================================</c>
<c>* Setup</c>
<c>*======================================</c>
<c></c>
<c> </c>
<c>*Generate default results</c>
<l>ImageOrder := []</l>
<l>gen_empty_obj(Images)</l>
<l>gen_empty_obj(Regions)</l>
<c></c>
<c>*GrabDataItems will be appended to this tuple so that a minimum amount</c>
<c>* of data will be transferred between the Ensenso camera and PC.</c>
<l>GrabDataItems := []</l>
<c>*GrabDataItemsRoot is for items that are calculated on the PC side via NxLibHandle.</c>
<l>GrabDataItemsRoot := []</l>
<c>*======================================</c>
<c>* Capture Images for 3D Reconstruction</c>
<c>*======================================</c>
<l>if(GetXYZ)</l>
<l>    GrabDataItems := [GrabDataItems, 'Images/PointMap']</l>
<c>    *Turn on the projector otherwise the point clouds will be very sparse</c>
<l>    set_framegrabber_param (AcqHandle, 'Parameters/Capture/Projector', 'true')</l>
<c>    </c>
<c>    *Set FlexView (N35 or X series only)</c>
<l>    tuple_is_number(FlexView,isNumber)</l>
<l>    if(isNumber)</l>
<l>        if(FlexView &gt; 16)</l>
<l>            ex := ['too many flexview patterns']</l>
<l>            throw(ex)</l>
<l>        endif</l>
<l>        if(FlexView == 0)</l>
<l>            FlexViewSetting := 'false'</l>
<l>        else</l>
<l>            FlexViewSetting := FlexView / 2 </l>
<l>        endif</l>
<l>    else</l>
<l>        FlexViewSetting := 'false'</l>
<l>    endif</l>
<l>    set_framegrabber_param (AcqHandle, 'Parameters/Capture/FlexView',FlexViewSetting)</l>
<c></c>
<c>    *determine whether to return regions - must use regions to generate normals!</c>
<l>    if(GenRegions or ComputeNormals)</l>
<l>        set_framegrabber_param (AcqHandle, 'generate_regions', 'true')</l>
<l>    else</l>
<l>        set_framegrabber_param (AcqHandle, 'generate_regions', 'false')</l>
<l>    endif</l>
<c>    *set exposure for the 3d acquisiton (separate from 2d)</c>
<l>    set_framegrabber_param (AcqHandle, 'Parameters/Capture/Exposure', Exposure3D)</l>
<c>    *capture images for 3d reconstruction. </c>
<l>    set_framegrabber_param (NxLibHandle, 'do_execute', 'Capture')</l>
<c>    *compute a disparity map from the images</c>
<l>    set_framegrabber_param (NxLibHandle, 'do_execute', 'ComputeDisparityMap')</l>
<c>    *compute a point map (XYZ image) from the disparity map</c>
<l>    set_framegrabber_param (NxLibHandle, 'do_execute', 'ComputePointMap')</l>
<c></c>
<l>    if(ComputeOrtho)</l>
<c>        *delta z for connecting the surface for render point map</c>
<l>        set_framegrabber_param (NxLibHandle, 'Parameters/SurfaceConnectivity', SurfaceConnectivity)</l>
<l>        set_framegrabber_param (NxLibHandle, 'Parameters/RenderPointMap/Size/', RenderPointMapSize)</l>
<c>        *Pixel size is px/mm</c>
<l>        set_framegrabber_param (NxLibHandle, 'Parameters/RenderPointMap/PixelSize', PixelSize)</l>
<l>        set_framegrabber_param(NxLibHandle,'do_execute','RenderPointMap')</l>
<l>        set_framegrabber_param (NxLibHandle, 'grab_data_items','Images/RenderPointMap')</l>
<l>        GrabDataItemsRoot := [GrabDataItemsRoot,'Images/RenderPointMap']</l>
<l>    endif</l>
<c>    </c>
<l>    if(ComputeNormals)</l>
<l>        NormalWindowRadius := (NormalWindowSize-1)/2</l>
<l>        set_framegrabber_param (NxLibHandle, 'ComputeNormals/Parameters/Radius', NormalWindowSize)</l>
<l>        set_framegrabber_param(NxLibHandle, 'do_execute', 'ComputeNormals')</l>
<l>        GrabDataItems := [GrabDataItems,'Images/Normals']</l>
<l>    endif</l>
<c></c>
<c>    </c>
<c>    *Grab all of the 3d data from the camera</c>
<l>    try</l>
<l>        if(|GrabDataItems| &gt; 0)</l>
<l>            set_framegrabber_param (AcqHandle, 'grab_data_items', GrabDataItems)</l>
<l>            grab_data (DeviceImages, Region, Contours, AcqHandle, Data)</l>
<l>        endif</l>
<c>        </c>
<l>        if(|GrabDataItemsRoot| &gt; 0)</l>
<l>            set_framegrabber_param (NxLibHandle, 'grab_data_items', GrabDataItemsRoot)</l>
<l>            grab_data (NxLibImages, Region, Contours, NxLibHandle, Data)</l>
<l>            concat_obj(Images, NxLibImages, Images)</l>
<l>            count_obj(NxLibImages,numNxImages)</l>
<l>            for i := 0 to numNxImages-1 by 1</l>
<l>                tuple_concat(ImageOrder, 'NxLibImages', ImageOrder)</l>
<l>            endfor</l>
<l>        endif</l>
<c>  </c>
<c>        *This is where the point cloud is created</c>
<l>        if(ComputeNormals)</l>
<l>            select_obj(DeviceImages,XYZImages,1)</l>
<l>            select_obj(DeviceImages,NormsImages,2)</l>
<l>            decompose3(XYZImages,XImg,YImg,ZImg)            </l>
<l>            decompose3(NormsImages,XnImg,YnImg,ZnImg)</l>
<c>            * create mask noisy normalized normals   </c>
<c>            * +/- 0.5773 is the value assigned to point normal components from points where kernel is degenerate</c>
<c>            * if you take an L2 norm of [0.5773, 0.5773, 0.5773] in an R3 space, it equals 1.  </c>
<l>            threshold(ZnImg,ZnMaskRegion,[0,0.5776],[0.5770,9999999999])</l>
<l>            select_obj(Region,RegionCoords,1)</l>
<l>            intersection(RegionCoords,ZnMaskRegion, ValidPixelMask)</l>
<l>            reduce_domain(ZImg,ValidPixelMask, ZImageReduced)</l>
<l>            xyz_attrib_to_object_model_3d (XImg, YImg, ZImg, NormsImages, ['point_normal_x','point_normal_y','point_normal_z'], ObjectModel3D)</l>
<l>        else</l>
<l>            decompose3(DeviceImages,XImg,YImg,ZImg)</l>
<l>            xyz_to_object_model_3d (XImg,YImg,ZImg,ObjectModel3D)</l>
<l>        endif</l>
<c>        </c>
<c>        ***THIS APPEARS TO ALREADY BE DONE IN XYZ_ATTRIB_TO_OM3D******</c>
<c>        *Set 2D mapping - this is required for edge-supported surface matching in Halcon</c>
<l>*         get_region_points(ValidPixelMask,CamRowsValid, CamColumnsValid) </l>
<l>*         get_image_size(XImg,ImageWidth,ImageHeight)</l>
<l>*         PixelMapping:=[ImageWidth,ImageHeight,CamRowsValid,CamColumnsValid]</l>
<l>*         set_object_model_3d_attrib_mod (ObjectModel3D, 'xyz_mapping', [], PixelMapping)</l>
<c>        </c>
<l>    catch(Exception)</l>
<l>        get_framegrabber_param (NxLibHandle, 'error_code', ErrorCode)</l>
<l>        if (ErrorCode == 17)</l>
<c>           * A command has failed to execute successfully. Print all information to identify what happened.</c>
<l>           get_framegrabber_param (NxLibHandle, 'Execute/Result/ErrorSymbol', ErrorSymbol)</l>
<l>           get_framegrabber_param (NxLibHandle, 'Execute/Result/ErrorText', ErrorText)</l>
<l>           throw ('The execution of a command failed with error ' + ErrorSymbol + '. Message: ' + ErrorText)</l>
<l>        else</l>
<c>           * Access to some tree node failed. Print the error code and corresponding text.</c>
<l>           get_framegrabber_param (NxLibHandle, 'error_item', ErrorItem)</l>
<l>           get_framegrabber_param (NxLibHandle, 'error_text', ErrorText)</l>
<l>           throw ('An NxLib API error ' + ErrorCode + ' occurred when accessing the item ' + ErrorItem + '. Message: ' + ErrorText)</l>
<l>        endif</l>
<l>    endtry</l>
<c></c>
<l>endif</l>
<c></c>
<c>*=====================================================================</c>
<c>*Capture 2D Images</c>
<c>*=====================================================================</c>
<l>if(GetLeftRect or GetRightRect)</l>
<l>    try      </l>
<c>        *set the exposure for the gray images</c>
<l>        set_framegrabber_param (AcqHandle, 'Parameters/Capture/Exposure', ExposureGray)</l>
<c>        *set the front light state</c>
<l>        if(IsLightOn)</l>
<l>            set_framegrabber_param (AcqHandle, 'Parameters/Capture/FrontLight', 'true')</l>
<l>        else</l>
<l>            set_framegrabber_param (AcqHandle, 'Parameters/Capture/FrontLight', 'false')</l>
<l>        endif</l>
<c>        *set the projector pattern state (always off when you just want a pretty camera image)</c>
<l>        set_framegrabber_param (AcqHandle, 'Parameters/Capture/Projector', 'false')</l>
<c>        *turn off FlexView, otherwise it will capture n images per camera rather than 1</c>
<l>        set_framegrabber_param (AcqHandle, 'Parameters/Capture/FlexView', 'false')</l>
<c>        </c>
<c>        *Grab the L/R Images</c>
<l>        gen_empty_obj(LeftImage)</l>
<l>        gen_empty_obj(RightImage)</l>
<l>        GrabList := []</l>
<l>        if(GetLeftRect)</l>
<l>            tuple_concat(GrabList,'Images/Rectified/Left',GrabList)</l>
<l>        endif</l>
<l>        if(GetRightRect)</l>
<l>            tuple_concat(GrabList,'Images/Rectified/Right',GrabList)</l>
<l>        endif</l>
<c>        </c>
<l>        set_framegrabber_param (AcqHandle, 'grab_data_items', GrabList)</l>
<l>        set_framegrabber_param (NxLibHandle,'do_execute','Capture')</l>
<l>        set_framegrabber_param (NxLibHandle, 'do_execute', 'RectifyImages')</l>
<l>        grab_data (EnsensoImages, Region, Contours, AcqHandle, Data)</l>
<c></c>
<c></c>
<c>        *Split the L/R Image tuple into individual images (select_obj is NOT a deep copy operation)</c>
<l>        try</l>
<l>            if(GetLeftRect)</l>
<l>                select_obj(EnsensoImages,LeftImage,1)</l>
<l>                if(GetRightRect)</l>
<l>                    select_obj(EnsensoImages,RightImage,2)</l>
<l>                endif</l>
<l>            elseif(GetRightRect)</l>
<l>                select_obj(EnsensoImages,RightImage,1)</l>
<l>            endif</l>
<l>        catch(ex)</l>
<l>        endtry</l>
<l>    catch(ex)</l>
<l>        throw('Error grabbing rectified images')</l>
<l>    endtry</l>
<c>    </c>
<l>    if(GetLeftRect)</l>
<l>        concat_obj(Images, LeftImage, Images)</l>
<l>        tuple_concat(ImageOrder, 'Left', ImageOrder)</l>
<l>    endif</l>
<c>    </c>
<l>    if(GetRightRect)</l>
<l>        concat_obj(Images, RightImage, Images)</l>
<l>        tuple_concat(ImageOrder, 'Right', ImageOrder)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*======================</c>
<c>* Get Disparity Map</c>
<c>*======================</c>
<l>if(GetXYZ == false and GetDisparity == true)</l>
<l>    throw('GetXYZ must be enabled to get disparity map')</l>
<l>endif</l>
<c></c>
<l>if(GetDisparity)</l>
<l>   set_framegrabber_param (AcqHandle, 'grab_data_items', ['Images/DisparityMap']) </l>
<l>   grab_data (ImageDisparity, R, C, AcqHandle, D)</l>
<l>   concat_obj(Images, ImageDisparity, Images)</l>
<l>   tuple_concat(ImageOrder, 'Disparity', ImageOrder)</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="ensenso_grab">
<abstract lang="en_US">By default this procedure returns nothing.  You must specify what to return via the general parameter names and values.  This is done to preserve network bandwidth.

The general parameter names are as follows:
'xyz' - returns the x, y, and z images as 3 objects ('true' or 'false')
'left_rect' - returns the left stereo rectified camera image ('true' or 'false')
'right_rect' - returns the right stereo rectified camera image ('true' or 'false')
'disparity' - returns the disparity image (column distance between corresponding points in left and right camera) ('true' or 'false')
'regions' - returns regions representing the area of the XYZ image that can be reconstructed ('true' or 'false')
'light_on' - turn the front light on while exposing the gray images ('true' or 'false')
'flexview' - number of pattern shifts/exposures to take (0 to 8)</abstract>
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<example lang="en_US">info_framegrabber ('Ensenso-NxLib', 'info_boards', Information, Serial)
ensenso_initialize (TestImage, Serial, 5, 'false', 'true', 'true', 'false', [], [], AcqHandle, NxLibHandle)   
Exposure3D:=4
ExposureGray:=6
GenParamNames := ['xyz',  'left_rect', 'right_rect', 'disparity', 'regions', 'light_on', 'flexview']
GenParamValues :=['true', 'true',      'true',       'false',     'false',   'false',    3]
ensenso_grab (Images, Regions, AcqHandle, NxLibHandle, ExposureGray, Exposure3D, GenParamNames, GenParamValues, ImageOrder)
ensenso_try_close (AcqHandle, NxLibHandle)</example>
<library lang="en_US">Ensenso</library>
<short lang="en_US">Grab data/images from Ensenso camera</short>
<parameters>
<parameter id="AcqHandle">
<description lang="en_US">Handle to the ensenso camera for grabbing images.</description>
</parameter>
<parameter id="Exposure3D">
<default_value>5</default_value>
<description lang="en_US">Exposure setting for 3d image acquisition.</description>
</parameter>
<parameter id="ExposureGray">
<default_value>4</default_value>
<description lang="en_US">Exposure value for the gray image (untextured) acquisition.</description>
</parameter>
<parameter id="GenParamNames">
<default_value>['xyz']</default_value>
<values>
<item>'xyz'</item>
<item>'left_rect'</item>
<item>'right_rect'</item>
<item>'disparity'</item>
<item>'regions'</item>
<item>'light_on'</item>
<item>'flexview'</item>
</values>
</parameter>
<parameter id="GenParamValues">
<default_value>['true']</default_value>
<values>
<item>'true'</item>
<item>'true'</item>
<item>'true'</item>
<item>'false'</item>
<item>'false'</item>
<item>'false'</item>
<item>3</item>
</values>
</parameter>
<parameter id="ImageOrder">
<description lang="en_US">Output tuple that describes the order of the images that were requested</description>
</parameter>
<parameter id="Images">
<description lang="en_US">Tuple of output images.  See the 'ImageOrder' output tuple for more info.</description>
</parameter>
<parameter id="NxLibHandle">
<description lang="en_US">Handle to the root node of the Ensenso parameter tree.  This is used for data operations.</description>
</parameter>
<parameter id="ObjectModel3D"/>
<parameter id="Regions">
<description lang="en_US">Regions where the sensor can reconstruct 3d points.  Enable/disable region output with the 'region' setting for general parameter names/values.</description>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_grab_rect">
<interface>
<oo>
<par name="RightImage" base_type="iconic" dimension="0"/>
<par name="LeftImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="ExposureMS" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>if(|GenParamNames| != |GenParamValues|)</l>
<l>    throw('Number of gen param names and values are not equal')</l>
<l>endif</l>
<c></c>
<l>IsLightOn := 'false'</l>
<l>IsProjectorOn := 'false'</l>
<c></c>
<l>GrabLeft := false</l>
<l>GrabRight := false</l>
<c></c>
<l>for i := 0 to |GenParamNames|-1 by 1</l>
<l>    if(GenParamNames[i] == 'light_on')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            IsLightOn := 'true'</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'projector_on')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            IsProjectorOn := 'true'</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'left')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GrabLeft := true</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(GenParamNames[i] == 'right')</l>
<l>        if(GenParamValues[i] == 'true')</l>
<l>            GrabRight := true</l>
<l>        endif</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>*get auto grab data state and turn it off temporarily</c>
<l>get_framegrabber_param(AcqHandle,'auto_grab_data',IsAutoGrabData)</l>
<l>set_framegrabber_param(AcqHandle,'auto_grab_data','false')</l>
<c></c>
<c>*set the exposure for the gray images</c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/Exposure', ExposureMS)</l>
<c></c>
<c>*set the front light state</c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/FrontLight', 'true')</l>
<c></c>
<c>*set the projector pattern state</c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/Projector', 'false')</l>
<c></c>
<c>*set the flexview parameter, otherwise it will capture n images per camera rather than 1</c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/FlexView', 1)</l>
<c></c>
<c>*Grab the L/R Images</c>
<l>gen_empty_obj(LeftImage)</l>
<l>gen_empty_obj(RightImage)</l>
<l>GrabList := []</l>
<l>if(GrabLeft)</l>
<l>    tuple_concat(GrabList,'Images/Rectified/Left',GrabList)</l>
<l>endif</l>
<l>if(GrabRight)</l>
<l>    tuple_concat(GrabList,'Images/Rectified/Right',GrabList)</l>
<l>endif</l>
<c></c>
<l>set_framegrabber_param (AcqHandle, 'grab_data_items', GrabList)</l>
<l>set_framegrabber_param (NxLibHandle,'do_execute','Capture')</l>
<l>set_framegrabber_param (NxLibHandle, 'do_execute', 'RectifyImages')</l>
<l>grab_data (EnsensoImages, Region, Contours, AcqHandle, Data)</l>
<c></c>
<c>*reset auto grab data</c>
<l>set_framegrabber_param(AcqHandle,'auto_grab_data',IsAutoGrabData)</l>
<c></c>
<c>*Split the L/R Image tuple into individual images (select_obj is NOT a deep copy operation)</c>
<l>try</l>
<l>    if(GrabLeft)</l>
<l>        select_obj(EnsensoImages,LeftImage,1)</l>
<l>    endif</l>
<l>catch(ex)</l>
<l>endtry</l>
<l>try</l>
<l>    if(GrabLeft)</l>
<l>        select_obj(EnsensoImages,RightImage,2)</l>
<l>    elseif(GrabRight)</l>
<l>        select_obj(EnsensoImages,RightImage,1)</l>
<l>    endif</l>
<l>catch(ex)</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="ensenso_grab_rect">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="ExposureMS"/>
<parameter id="GenParamNames"/>
<parameter id="GenParamValues"/>
<parameter id="LeftImage"/>
<parameter id="NxLibHandle"/>
<parameter id="RightImage"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_grab_xyz">
<interface>
<oo>
<par name="X" base_type="iconic" dimension="0"/>
<par name="Y" base_type="iconic" dimension="0"/>
<par name="Z" base_type="iconic" dimension="0"/>
<par name="Regions" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="ExposureMS" base_type="ctrl" dimension="0"/>
<par name="GenRegions" base_type="ctrl" dimension="0"/>
<par name="FlexView" base_type="ctrl" dimension="0"/>
<par name="ComputeNormals" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>if(GenRegions == 1)</l>
<l>    GenRegions := 'true'</l>
<l>endif</l>
<c></c>
<c>*Set FlexView</c>
<l>tuple_is_number(FlexView,isNumber)</l>
<l>if(isNumber)</l>
<l>    if(FlexView &gt; 16)</l>
<l>        ex := ['too many flexview patterns']</l>
<l>        throw(ex)</l>
<l>    endif</l>
<l>    FlexViewSetting := FlexView / 2 </l>
<l>else</l>
<l>    FlexViewSetting := 'false'</l>
<l>endif</l>
<c></c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/FlexView',FlexViewSetting)</l>
<c> </c>
<l>set_framegrabber_param (AcqHandle, 'generate_regions', GenRegions)</l>
<c></c>
<l>set_framegrabber_param (AcqHandle, 'Parameters/Capture/Exposure', ExposureMS)</l>
<c></c>
<c></c>
<c></c>
<l>*grab_data (ImageXYZ, Regions, Contours, AcqHandle, Data)</l>
<c></c>
<l>set_framegrabber_param(AcqHandle,'auto_grab_data','false')</l>
<l>GrabDataItems := ['Images/PointMap']</l>
<c></c>
<l>set_framegrabber_param (NxLibHandle, 'do_execute', 'Capture')</l>
<l>set_framegrabber_param (NxLibHandle, 'do_execute', 'ComputeDisparityMap')</l>
<l>set_framegrabber_param (NxLibHandle, 'do_execute', 'ComputePointMap')</l>
<l>if(ComputeNormals == 'true')</l>
<l>    set_framegrabber_param (NxLibHandle, 'do_execute', 'ComputeNormals')</l>
<l>    GrabDataItems := [GrabDataItems, 'Images/Normals']</l>
<l>endif</l>
<c></c>
<l>set_framegrabber_param (AcqHandle, 'grab_data_items', GrabDataItems)</l>
<l>*set_framegrabber_param (NxLibHandle, 'exec:Parameters/FinalTrigger', 'All')</l>
<l>grab_data (ImageXYZ, Regions, Contours, AcqHandle, Data)</l>
<c></c>
<c></c>
<c>*Split the result data into individual images (access_channel MAY be a deep copy method)</c>
<l>tuple_length(GrabDataItems, NumGrabDataItems)</l>
<l>if(NumGrabDataItems == 1)</l>
<c>    *coordinate images only</c>
<l>    access_channel (ImageXYZ, X, 1)   </l>
<l>    access_channel (ImageXYZ, Y, 2) </l>
<l>    access_channel (ImageXYZ, Z, 3)    </l>
<l>elseif(NumGrabDataItems == 2)</l>
<c>    *collect normals as another channel of coordinate images</c>
<l>    select_obj(ImageXYZ, ImageCoords, 1)</l>
<l>    access_channel (ImageCoords, Xc, 1)   </l>
<l>    access_channel (ImageCoords, Yc, 2) </l>
<l>    access_channel (ImageCoords, Zc, 3)  </l>
<l>    select_obj(ImageXYZ, ImageNorms, 2)</l>
<l>    access_channel (ImageNorms, Xn, 1)</l>
<l>    access_channel (ImageNorms, Yn, 2)</l>
<l>    access_channel (ImageNorms, Zn, 3)</l>
<l>    concat_obj(Xc,Xn,X)</l>
<l>    concat_obj(Yc,Yn,Y)</l>
<l>    concat_obj(Zc,Zn,Z)</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_grab_xyz">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="ComputeNormals"/>
<parameter id="ExposureMS"/>
<parameter id="FlexView"/>
<parameter id="GenRegions"/>
<parameter id="NxLibHandle"/>
<parameter id="Regions"/>
<parameter id="X"/>
<parameter id="Y"/>
<parameter id="Z"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_hom_mat3d_to_quat">
<interface>
<ic>
<par name="RotationMatrix" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Quaternion" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*****************************************************************************************************</c>
<c>* Convert from rotation matrix to quaternion</c>
<c>* </c>
<c>* Code translated from:</c>
<c>* http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche52.html</c>
<c>*</c>
<c>* Author: Justin Swick</c>
<c>* Date:   7-11-16</c>
<c>*****************************************************************************************************</c>
<c></c>
<l>Mat := RotationMatrix</l>
<c></c>
<c>*inline float SIGN(float x) {return (x &gt;= 0.0f) ? +1.0f : -1.0f;}</c>
<c>*inline float NORM(float a, float b, float c, float d) {return sqrt(a * a + b * b + c * c + d * d);}</c>
<c></c>
<l>q0 := ( Mat[0] + Mat[5] + Mat[10] + 1.0) / 4.0</l>
<l>q1 := ( Mat[0] - Mat[5] - Mat[10] + 1.0) / 4.0</l>
<l>q2 := (-Mat[0] + Mat[5] - Mat[10] + 1.0) / 4.0</l>
<l>q3 := (-Mat[0] - Mat[5] + Mat[10] + 1.0) / 4.0</l>
<c></c>
<l>if(q0 &lt; 0) </l>
<l>    q0 := 0</l>
<l>endif</l>
<l>if(q1 &lt; 0)</l>
<l>    q1 := 0</l>
<l>endif</l>
<l>if(q2 &lt; 0)</l>
<l>    q2 := 0</l>
<l>endif</l>
<l>if(q3 &lt; 0)</l>
<l>    q3 := 0</l>
<l>endif</l>
<l>tuple_sqrt(q0,q0)</l>
<l>tuple_sqrt(q1,q1)</l>
<l>tuple_sqrt(q2,q2)</l>
<l>tuple_sqrt(q3,q3)</l>
<c></c>
<l>if(q0 &gt;= q1 and q0 &gt;= q2 and q0 &gt;= q3) </l>
<c>    *q0 *= +1.0f</c>
<l>    q0 := q0</l>
<c>    *q1 *= SIGN(r32 - r23)</c>
<l>    ensenso_quat_sign (q1, Mat[9] - Mat[6], q1)</l>
<c>    *q2 *= SIGN(r13 - r31)</c>
<l>    ensenso_quat_sign (q2, Mat[2] - Mat[8], q2)</l>
<c>    *q3 *= SIGN(r21 - r12)</c>
<l>    ensenso_quat_sign (q3, Mat[4] - Mat[1], q3)</l>
<l>elseif(q1 &gt;= q0 and q1 &gt;= q2 and q1 &gt;= q3)</l>
<c>    *q0 *= SIGN(r32 - r23)</c>
<l>    ensenso_quat_sign (q0, Mat[9] - Mat[6], q0)</l>
<c>    *q1 *= +1.0f</c>
<l>    q1 := q1</l>
<c>    *q2 *= SIGN(r21 + r12)</c>
<l>    ensenso_quat_sign (q2, Mat[9] + Mat[6], q2)</l>
<c>    *q3 *= SIGN(r13 + r31)</c>
<l>    ensenso_quat_sign (q3, Mat[4] + Mat[1], q3)</l>
<l>elseif(q2 &gt;= q0 and q2 &gt;= q1 and q2 &gt;= q3)</l>
<c>    *q0 *= SIGN(r13 - r31)</c>
<l>    ensenso_quat_sign (q0, Mat[2] - Mat[8], q0)</l>
<c>    *q1 *= SIGN(r21 + r12)</c>
<l>    ensenso_quat_sign (q1, Mat[4] + Mat[1], q1)</l>
<c>    *q2 *= +1.0f</c>
<l>    q2 := q2</l>
<c>    *q3 *= SIGN(r32 + r23)</c>
<l>    ensenso_quat_sign (q3, Mat[9] + Mat[6], q3)</l>
<l>elseif(q3 &gt;= q0 and q3 &gt;= q1 and q3 &gt;= q2)</l>
<c>    *q0 *= SIGN(r21 - r12)</c>
<l>    ensenso_quat_sign (q0, Mat[4] - Mat[1], q0)</l>
<c>    *q1 *= SIGN(r31 + r13)</c>
<l>    ensenso_quat_sign (q1, Mat[8] + Mat[2], q1)</l>
<c>    *q2 *= SIGN(r32 + r23)</c>
<l>    ensenso_quat_sign (q2, Mat[9] + Mat[6], q2)</l>
<c>    *q3 *= +1.0f</c>
<l>    q3 := q3</l>
<l>else</l>
<l>    ex := 'Programming error in ensenso_quat_to_mat3d'</l>
<l>    throw(ex)</l>
<l>endif</l>
<l>tuple_sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3, r)</l>
<l>Quaternion := [q0, q1, q2, q3]/r</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
<c>*ORIGINAL SOURCE CODE:</c>
<c>*</c>
<c>* inline float SIGN(float x) {return (x &gt;= 0.0f) ? +1.0f : -1.0f;}</c>
<c>* inline float NORM(float a, float b, float c, float d) {return sqrt(a * a + b * b + c * c + d * d);}</c>
<c></c>
<c>* q0 = ( r11 + r22 + r33 + 1.0f) / 4.0f;</c>
<c>* q1 = ( r11 - r22 - r33 + 1.0f) / 4.0f;</c>
<c>* q2 = (-r11 + r22 - r33 + 1.0f) / 4.0f;</c>
<c>* q3 = (-r11 - r22 + r33 + 1.0f) / 4.0f;</c>
<c>* if(q0 &lt; 0.0f) q0 = 0.0f;</c>
<c>* if(q1 &lt; 0.0f) q1 = 0.0f;</c>
<c>* if(q2 &lt; 0.0f) q2 = 0.0f;</c>
<c>* if(q3 &lt; 0.0f) q3 = 0.0f;</c>
<c>* q0 = sqrt(q0);</c>
<c>* q1 = sqrt(q1);</c>
<c>* q2 = sqrt(q2);</c>
<c>* q3 = sqrt(q3);</c>
<c>* if(q0 &gt;= q1 &amp;&amp; q0 &gt;= q2 &amp;&amp; q0 &gt;= q3) {</c>
<c>*     q0 *= +1.0f;</c>
<c>*     q1 *= SIGN(r32 - r23);</c>
<c>*     q2 *= SIGN(r13 - r31);</c>
<c>*     q3 *= SIGN(r21 - r12);</c>
<c>*} else if(q1 &gt;= q0 &amp;&amp; q1 &gt;= q2 &amp;&amp; q1 &gt;= q3) {</c>
<c>*     q0 *= SIGN(r32 - r23);</c>
<c>*     q1 *= +1.0f;</c>
<c>*     q2 *= SIGN(r21 + r12);</c>
<c>*     q3 *= SIGN(r13 + r31);</c>
<c>*} else if(q2 &gt;= q0 &amp;&amp; q2 &gt;= q1 &amp;&amp; q2 &gt;= q3) {</c>
<c>*     q0 *= SIGN(r13 - r31);</c>
<c>*     q1 *= SIGN(r21 + r12);</c>
<c>*     q2 *= +1.0f;</c>
<c>*     q3 *= SIGN(r32 + r23);</c>
<c>*} else if(q3 &gt;= q0 &amp;&amp; q3 &gt;= q1 &amp;&amp; q3 &gt;= q2) {</c>
<c>*     q0 *= SIGN(r21 - r12);</c>
<c>*     q1 *= SIGN(r31 + r13);</c>
<c>*     q2 *= SIGN(r32 + r23);</c>
<c>*     q3 *= +1.0f;</c>
<c>*} else {</c>
<c>*     printf("coding error\n");</c>
<c>*}</c>
<c>* r = NORM(q0, q1, q2, q3);</c>
<c>* q0 /= r;</c>
<c>* q1 /= r;</c>
<c>* q2 /= r;</c>
<c>* q3 /= r;</c>
</body>
<docu id="ensenso_hom_mat3d_to_quat">
<parameters>
<parameter id="Quaternion"/>
<parameter id="RotationMatrix"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_initialize">
<interface>
<oo>
<par name="TestImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="SerialNumber" base_type="ctrl" dimension="0"/>
<par name="Exposure" base_type="ctrl" dimension="0"/>
<par name="GrabRaw" base_type="ctrl" dimension="0"/>
<par name="GrabRect" base_type="ctrl" dimension="0"/>
<par name="GrabXYZ" base_type="ctrl" dimension="0"/>
<par name="GrabRegions" base_type="ctrl" dimension="0"/>
<par name="GenParamNames" base_type="ctrl" dimension="0"/>
<par name="GenParamValues" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*Validate the SerialNumber parameter</c>
<l>tuple_strlen(SerialNumber,SerialLength)</l>
<l>if(SerialLength &lt; 5)</l>
<c>    * Open the first available stereo camera</c>
<l>    info_framegrabber ('Ensenso-NxLib', 'info_boards', Information, Status)</l>
<l>    tuple_regexp_test(Status,'available',numMatches)</l>
<l>    if(numMatches == 0)</l>
<l>        tuple_regexp_test(Status,'used',numMatches)</l>
<l>        if(numMatches == 1)</l>
<l>            throw('Connection error: ensenso is in use.  Info: '+ Status)</l>
<l>        else</l>
<l>            throw('Connection error: ensenso cannot connect.  Info: '+ Status)</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>try</l>
<c>*Open a camera device.  This will be used with grab_image or grab_data.</c>
<l>open_framegrabber ('Ensenso-NxLib', 0, 0, 0, 0, 0, 0, 'default', -1, 'Rectified', \
                   'auto_grab_data=0', 'default', 'stereo', SerialNumber, 0, -1, AcqHandle)</l>
<l>catch(ex)</l>
<l>    throw('Error opening camera: \n'+ex)</l>
<l>endtry</l>
<c></c>
<l>try</l>
<c>*Open the NxLib root node.  This allows access to all items in the NxLib DLL.  Think of this</c>
<c>* as the PC and AcqHandle as the device</c>
<l>open_framegrabber ('Ensenso-NxLib', 0, 0, 0, 0, 0, 0, 'default', -1, 'Raw', \
                   'auto_grab_data=0', 'default', 'Item', '/', 0, -1, NxLibHandle)</l>
<l>catch(ex)</l>
<l>    throw('Error opening NxLib root node: \n'+ex)</l>
<l>endtry</l>
<c></c>
<l>try</l>
<c>*Open a tcp port, so the internal tree can be browsed with NxTreeView:</c>
<l>set_framegrabber_param(NxLibHandle, 'do_open_tcp_port', 24000)</l>
<l>catch(ex)</l>
<l>    Error := -1</l>
<l>endtry</l>
<c></c>
<c>*always wait for the projector led to charge fully, otherwise if you exceed the duty cycle</c>
<c>* of the device, the images will get dim as the cycle time shortens.</c>
<l>set_framegrabber_param (NxLibHandle, 'Capture/Parameters/WaitForProjector', 'true')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_initialize">
<abstract lang="en_US">This procedure simplifies connection / initialization of the Ensenso N-series stereo 3d sensor.</abstract>
<alternatives>
<item>open_framegrabber</item>
</alternatives>
<keywords lang="en_US">
<item>ensenso</item>
</keywords>
<short lang="en_US">Initialize an Ensenso N-series stereo 3d sensor</short>
<parameters>
<parameter id="AcqHandle">
<description lang="en_US">Handle of the selected Ensenso sensor</description>
</parameter>
<parameter id="Error"/>
<parameter id="Exposure">
<default_value>0</default_value>
<description lang="en_US">Exposure in milliseconds, choose 0 for auto</description>
</parameter>
<parameter id="GenParamNames">
<default_value>[]</default_value>
<values>
<item>'camera_type'</item>
<item>'color_space'</item>
<item>'auto_grab_data'</item>
</values>
</parameter>
<parameter id="GenParamValues">
<default_value>[]</default_value>
<values>
<item>'Stereo'</item>
<item>'Monocular'</item>
<item>'Raw'</item>
<item>'Rectified'</item>
<item>'false'</item>
<item>'true'</item>
</values>
</parameter>
<parameter id="GrabRaw">
<default_value>'false'</default_value>
<description lang="en_US">Grab the raw camera image (not rectified, distorted)</description>
</parameter>
<parameter id="GrabRect">
<default_value>'true'</default_value>
<description lang="en_US">Grab the rectified camera images</description>
</parameter>
<parameter id="GrabRegions">
<default_value>'false'</default_value>
<description lang="en_US">Grab the valid regions</description>
</parameter>
<parameter id="GrabXYZ">
<default_value>'true'</default_value>
<description lang="en_US">Grab the XYZ images</description>
</parameter>
<parameter id="NxLibHandle"/>
<parameter id="SerialNumber">
<default_value>0</default_value>
<description lang="en_US">Serial number of the camera.  Get with info_framegrabber('Ensenso-NxLib','info_boards',Information,Values).  Use 0 if there is only one connected to the PC.</description>
</parameter>
<parameter id="TestImage"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_quat_sign">
<interface>
<ic>
<par name="q" base_type="ctrl" dimension="0"/>
<par name="x" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="y" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*SIGN(float x) {return (x &gt;= 0.0f) ? +1.0f : -1.0f;}</c>
<c></c>
<c>*q1 *= SIGN(r32 - r23)</c>
<c></c>
<l>if(x &gt;= 0)</l>
<l>    y := q * 1</l>
<l>else</l>
<l>    y := q * -1</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_quat_sign">
<parameters>
<parameter id="q"/>
<parameter id="x"/>
<parameter id="y"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_quat_to_axis_angle">
<interface>
<ic>
<par name="Quaternion" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Angle" base_type="ctrl" dimension="0"/>
<par name="RotationAxis" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>********************************************************************************************************</c>
<c>* Quaternion to Axis Angle</c>
<c>*</c>
<c>* Translated from Java code at:</c>
<c>* http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/</c>
<c>* http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/#normalise</c>
<c>*</c>
<c>* Author: Justin Swick</c>
<c>* Date:   7-11-16</c>
<c>********************************************************************************************************</c>
<c></c>
<c>* public void set(Quat4d q1) {</c>
<c>*    if (q1.w &gt; 1) q1.normalise(); // if w&gt;1 acos and sqrt will produce errors, this cant happen if quaternion is normalised</c>
<c>*    angle = 2 * Math.acos(q1.w);</c>
<c>*    double s = Math.sqrt(1-q1.w*q1.w); // assuming quaternion normalised then w is less than 1, so term always positive.</c>
<c>*    if (s &lt; 0.001) { // test to avoid divide by zero, s is always positive due to sqrt</c>
<c>*     // if s close to zero then direction of axis not important</c>
<c>*      x = q1.x; // if it is important that axis is normalised then replace with x=1; y=z=0;</c>
<c>*      y = q1.y;</c>
<c>*      z = q1.z;</c>
<c>*   } else {</c>
<c>*      x = q1.x / s; // normalise axis</c>
<c>*      y = q1.y / s;</c>
<c>*      z = q1.z / s;</c>
<c>*   }</c>
<c>*}</c>
<c></c>
<c>*http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/#normalise</c>
<c>* public final void normalise() {</c>
<c>*     double n = Math.sqrt(x*x + y*y + z*z + w*w);</c>
<c>*     x /= n;</c>
<c>*     y /= n;</c>
<c>*     z /= n;</c>
<c>*     w /= n;</c>
<c>*}</c>
<c></c>
<c></c>
<l>q0 := Quaternion[0]</l>
<l>q1 := Quaternion[1]</l>
<l>q2 := Quaternion[2]</l>
<l>q3 := Quaternion[3]</l>
<c></c>
<l>if(q0 &gt; 1)</l>
<c>    *if w&gt;1 acos and sqrt will produce errors.  Normalize to prevent this</c>
<c>    *http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/#normalise</c>
<l>    magnitude := sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3)</l>
<l>    q0 := q0 / magnitude</l>
<l>    q1 := q1 / magnitude</l>
<l>    q2 := q2 / magnitude</l>
<l>    q3 := q3 / magnitude</l>
<l>endif</l>
<c></c>
<c>*angle is 2*acos(w)</c>
<l>Angle := 2*acos(q0)</l>
<c></c>
<c>*check that s &gt; 0 (causes divide by zero error).  If s is very near 0, then direction of axis is not important</c>
<l>s := sqrt(1-q0*q0)</l>
<l>if(s &lt; 0.0001)</l>
<l>    RotationAxis[0] := q1</l>
<l>    RotationAxis[1] := q2</l>
<l>    RotationAxis[2] := q3</l>
<l>else</l>
<c>    *normalize axes</c>
<l>    RotationAxis[0] := q1 / s</l>
<l>    RotationAxis[1] := q2 / s</l>
<l>    RotationAxis[2] := q3 / s</l>
<l>endif</l>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="ensenso_quat_to_axis_angle">
<parameters>
<parameter id="Angle"/>
<parameter id="Quaternion"/>
<parameter id="RotationAxis"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_read_calibration">
<interface>
<ic>
<par name="FilePath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CalParameterNames" base_type="ctrl" dimension="0"/>
<par name="CalParameterValues" base_type="ctrl" dimension="0"/>
<par name="CalibrationJSON" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***********************************************************************************************************************</c>
<c>* ENSENSO READ CALIBRATION</c>
<c>***********************************************************************************************************************</c>
<c>* Created: 7/8/16</c>
<c>* Author: Justin Swick</c>
<c>* </c>
<c>* Summary:</c>
<c>* This reads a calibration file, parses the tree structure, and pulls out each path name / value into two tuples where</c>
<c>* the indices of each tuple match for a particular setting.  Then it filters the resulting output tuples for calibration</c>
<c>* elements only</c>
<c>*</c>
<c>*</c>
<c>* Change Log</c>
<c>* Version      Date       Changes</c>
<c>* =======      ====       =============================================================================================</c>
<c>* 0.1          7/8/16     First working version</c>
<c>*</c>
<c>*</c>
<c>*</c>
<c>***********************************************************************************************************************</c>
<l>*stop()</l>
<c>*ensenso_read_json (FilePath, Names, Values)</c>
<c></c>
<l>open_file(FilePath,'input',calibHandle)</l>
<l>CalibrationJSON := ''</l>
<l>isEOF := 0</l>
<l>while(isEOF != 1)</l>
<l>    fread_line(calibHandle,Line,isEOF)</l>
<l>    CalibrationJSON := CalibrationJSON + Line</l>
<l>endwhile</l>
<c></c>
<l>close_file(calibHandle)</l>
<c></c>
<l>* CalParameterNames := []</l>
<l>* CalParameterValues := []</l>
<l>* for i:=0 to |Names|-1 by 1</l>
<l>*     tuple_regexp_test(Names[i],'Calibration',NumMatches)</l>
<l>*     if(NumMatches == 1)</l>
<l>*         tuple_concat(CalParameterNames, Names[i], CalParameterNames)</l>
<l>*         tuple_concat(CalParameterValues, Values[i], CalParameterValues)</l>
<l>*     endif</l>
<l>* endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_read_calibration">
<parameters>
<parameter id="CalParameterNames"/>
<parameter id="CalParameterValues"/>
<parameter id="CalibrationJSON"/>
<parameter id="FilePath"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_read_settings">
<interface>
<ic>
<par name="FilePath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParameterNames" base_type="ctrl" dimension="0"/>
<par name="ParameterValues" base_type="ctrl" dimension="0"/>
<par name="ParametersJSON" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>***********************************************************************************************************************</c>
<c>* ENSENSO READ SETTINGS</c>
<c>***********************************************************************************************************************</c>
<c>* Created: 2/8/17</c>
<c>* Author: Justin Swick</c>
<c>* </c>
<c>* Summary:</c>
<c>* This reads a settings / parameters file, parses the tree structure, and pulls out each path name / value into two tuples where</c>
<c>* the indices of each tuple match for a particular setting.  Then it filters the resulting output tuples for calibration</c>
<c>* elements only</c>
<c>*</c>
<c>*</c>
<c>* Change Log</c>
<c>* Version      Date       Changes</c>
<c>* =======      ====       =============================================================================================</c>
<c>* 0.1          2/8/17     First working version</c>
<c>*</c>
<c>*</c>
<c>*</c>
<c>***********************************************************************************************************************</c>
<l>*stop()</l>
<c></c>
<l>open_file(FilePath,'input',settingsFileHandle)</l>
<l>ParametersJSON := ''</l>
<l>isEOF := 0</l>
<l>while(isEOF != 1)</l>
<l>    fread_line(settingsFileHandle,Line,isEOF)</l>
<l>    ParametersJSON := ParametersJSON + Line</l>
<l>endwhile</l>
<c></c>
<l>close_file(settingsFileHandle)</l>
<c></c>
<l>* CalParameterNames := []</l>
<l>* CalParameterValues := []</l>
<l>* for i:=0 to |Names|-1 by 1</l>
<l>*     tuple_regexp_test(Names[i],'Calibration',NumMatches)</l>
<l>*     if(NumMatches == 1)</l>
<l>*         tuple_concat(CalParameterNames, Names[i], CalParameterNames)</l>
<l>*         tuple_concat(CalParameterValues, Values[i], CalParameterValues)</l>
<l>*     endif</l>
<l>* endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_read_settings">
<parameters>
<parameter id="FilePath"/>
<parameter id="ParameterNames"/>
<parameter id="ParameterValues"/>
<parameter id="ParametersJSON"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_set_calibration">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="CalibrationParameters" base_type="ctrl" dimension="0"/>
<par name="CalParameterNames" base_type="ctrl" dimension="0"/>
<par name="CalParameterValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*First apply the ensenso settings tuple</c>
<l>if(CalibrationParameters != '')</l>
<l>    set_framegrabber_param(AcqHandle,'',['apply', CalibrationParameters])</l>
<l>endif</l>
<c></c>
<c>*Apply individual parameters</c>
<l>for i:=0 to |CalParameterNames|-1 by 1</l>
<l>    set_framegrabber_param(AcqHandle,CalParameterNames[i], CalParameterValues[i])</l>
<l>endfor</l>
<l>return ()</l>
</body>
<docu id="ensenso_set_calibration">
<abstract lang="en_US">Set the calibration for an Ensenso using either a calibration string retrieved from a device, loaded from a file, or individual calibration parameters and values.  Note: calibration parameters and values are applied AFTER the calibration string.</abstract>
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<library lang="en_US">Ensenso</library>
<parameters>
<parameter id="AcqHandle"/>
<parameter id="CalParameterNames"/>
<parameter id="CalParameterValues"/>
<parameter id="CalibrationParameters"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_set_pose">
<interface>
<ic>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
<par name="PoseInWorldCoordinates" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>info_framegrabber ('Ensenso-NxLib', 'device', Information, Serial)</l>
<c></c>
<c>*read rotation/angle</c>
<l>*     get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Rotation/Angle', RotationAngle)</l>
<c>    *read rotation/axis</c>
<l>*     get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Rotation/Axis', RotationAxis)</l>
<c>    *read workspace translation</c>
<l>*     get_framegrabber_param (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/Translation', WorkspaceTranslation)</l>
<c>    </c>
<l>*     tuple_regexp_replace(RotationAxis,['\\[','replace_all'],'',Result1)</l>
<l>*     tuple_regexp_replace(Result1,['\\]','replace_all'],'',Result2)</l>
<l>*     tuple_split(Result2,',',ResultStr)</l>
<l>*     tuple_number(ResultStr,RotationAxis)</l>
<c>    </c>
<l>*     tuple_regexp_replace(WorkspaceTranslation,['\\[','replace_all'],'',Result1)</l>
<l>*     tuple_regexp_replace(Result1,['\\]','replace_all'],'',Result2)</l>
<l>*     tuple_split(Result2,',',ResultStr)</l>
<l>*     tuple_number(ResultStr,WorkspaceTranslation)</l>
<c></c>
<l>* axis_angle_to_quat(RotationAxis[0],RotationAxis[1],RotationAxis[2],RotationAngle,PoseQuaternion)</l>
<l>* quat_to_hom_mat3d (PoseQuaternion,PoseRotationMatrix)</l>
<l>* hom_mat3d_translate(PoseRotationMatrix,WorkspaceTranslation[0],WorkspaceTranslation[1],WorkspaceTranslation[2],PoseHomMat3D)</l>
<l>* hom_mat3d_to_pose (PoseHomMat3D,CameraPose)</l>
<c></c>
<l>* PoseInWorldCoordinates := CameraPose</l>
<c></c>
<c>*get XYZ translation from ensenso pose</c>
<l>* WorkspaceTranslation[0] := PoseInWorldCoordinates[0]</l>
<l>* WorkspaceTranslation[1] := PoseInWorldCoordinates[1]</l>
<l>* WorkspaceTranslation[2] := PoseInWorldCoordinates[2]</l>
<c></c>
<c>*convert ensenso pose to homogeneous matrix</c>
<l>* pose_to_hom_mat3d(PoseInWorldCoordinates,PoseHomMat3D)</l>
<c></c>
<c>*translate the pose to the origin so that rotation axes and angles can be obtained</c>
<l>* hom_mat3d_translate(PoseHomMat3D,-WorkspaceTranslation[0],-WorkspaceTranslation[1],-WorkspaceTranslation[2],PoseRotationMatrix)</l>
<c></c>
<c>*calculate the quaternion representation of the rotation matrix</c>
<c>*TODO: test in singularity and the example poses from this website</c>
<c>* http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/examples/index.htm</c>
<l>* ensenso_hom_mat3d_to_quat (PoseRotationMatrix, Quaternion)</l>
<c></c>
<l>* ensenso_quat_to_axis_angle (Quaternion, Angle2, RotationAxis2)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>nxLibSetPose (NxLibHandle, 'Cameras/BySerialNo/'+Serial+'/Link/', PoseInWorldCoordinates)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*TODO: get serial number from handle and build path string automatically</c>
<l>*set_framegrabber_param(NxLibHandle,'Cameras/BySerialNo/'+Serial+'/Link/Translation', WorkspaceTranslation)</l>
<l>return ()</l>
</body>
<docu id="ensenso_set_pose">
<abstract lang="en_US">Set the Ensenso's pose relative to the world coordinate system</abstract>
<chapters lang="en_US">
<item>Ensenso</item>
</chapters>
<library lang="en_US">Ensenso</library>
<parameters>
<parameter id="NxLibHandle"/>
<parameter id="PoseInWorldCoordinates"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_set_settings">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="EnsensoParameters" base_type="ctrl" dimension="0"/>
<par name="ParameterNames" base_type="ctrl" dimension="0"/>
<par name="ParameterValues" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>if(|ParameterNames| != |ParameterValues|)</l>
<l>    throw('Number of param names and values are not equal')</l>
<l>endif</l>
<c></c>
<c>*First apply the ensenso parameters tuple</c>
<l>if(EnsensoParameters != '')</l>
<l>    set_framegrabber_param(AcqHandle,'Parameters',['apply',EnsensoParameters])</l>
<l>endif</l>
<c></c>
<c>*Apply individual parameters</c>
<l>for i:=0 to |ParameterNames|-1 by 1</l>
<l>    set_framegrabber_param(AcqHandle,ParameterNames[i], ParameterValues[i])</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_set_settings">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="EnsensoParameters"/>
<parameter id="ParameterNames"/>
<parameter id="ParameterValues"/>
</parameters>
</docu>
</procedure>
<procedure name="ensenso_try_close">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NxLibHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Error" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*ensenso has a handle for the cameras and the NxLib tree root (NxLibHandle).  Both must be closed to release the device.</c>
<l>Error := 0</l>
<c></c>
<l>try</l>
<l>    set_framegrabber_param(NxLibHandle, 'do_close_tcp_port', [])</l>
<l>catch(ex)</l>
<l>    Error := -3</l>
<l>endtry</l>
<c></c>
<l>try</l>
<l>close_framegrabber (AcqHandle)</l>
<l>catch(ex)</l>
<l>    Error := -1</l>
<l>endtry</l>
<l>try</l>
<l>close_framegrabber (NxLibHandle)</l>
<l>catch(ex)</l>
<l>    Error := -2</l>
<l>endtry</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="ensenso_try_close">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="Error"/>
<parameter id="NxLibHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="jsonToTuple">
<interface>
<ic>
<par name="JsonString" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MatrixID" base_type="ctrl" dimension="0"/>
<par name="Values" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>tuple_type (JsonString, Type)</l>
<l>if (Type == H_TYPE_STRING)</l>
<c>    * Es handelt sich um den Datentyp String</c>
<c>    * THIS IS THE STRING DATATYPE</c>
<l>    tuple_strstr (JsonString, '[[', Position)</l>
<l>    if (Position != -1)</l>
<c>        * Es handelt sich um eine Matrix</c>
<c>        * IT IS A TUPLE</c>
<l>        tuple_strlen (JsonString, Length)</l>
<l>        tuple_substr (JsonString, 1, Length-2, JsonString)</l>
<l>    endif</l>
<c>    * </c>
<l>    AllSubstrings := []</l>
<l>    while (true)</l>
<c>        * Zerlege die Matrix in ihre Eintraege</c>
<c>        * DISASSEMBLE THE TUPLE INTO ITS ELEMENTS</c>
<l>        tuple_strstr (JsonString, '],[', Position)</l>
<l>        tuple_strlen (JsonString, Length)</l>
<l>        if (Position != -1)</l>
<l>            tuple_substr (JsonString, 0, Position, Substring)</l>
<l>            AllSubstrings := [AllSubstrings, Substring]</l>
<l>            tuple_substr (JsonString, Position+2, Length-1, JsonString)</l>
<l>        else</l>
<l>            AllSubstrings := [AllSubstrings, JsonString]</l>
<l>            JsonString := AllSubstrings</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<c>    * </c>
<l>    Dimension := |JsonString|</l>
<l>    Values := []</l>
<l>    for i := 0 to Dimension-1 by 1</l>
<l>        StringTmp := JsonString[i]</l>
<l>        tuple_strlen (StringTmp, Length)</l>
<l>        tuple_substr (StringTmp, 1, Length-2, StringTmpStr)</l>
<l>        tuple_split (StringTmpStr, ',', Substrings)</l>
<l>        for j := 0 to |Substrings|-1 by 1</l>
<l>            tuple_number (Substrings[j], Number)</l>
<l>            Values := [Values, Number]</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    * </c>
<l>    if (Dimension)</l>
<l>        NumEntries := |Values| / Dimension</l>
<l>        create_matrix (Dimension, NumEntries, Values, MatrixID)</l>
<l>        transpose_matrix_mod (MatrixID)</l>
<l>    endif</l>
<c>    * </c>
<l>elseif (Type == H_TYPE_REAL)</l>
<c>    * Es handelt sich um einen Real-Eintrag</c>
<c>    * THIS ENTRY IS A REAL DATA TYPE</c>
<l>    Values := JsonString</l>
<l>    Dimension := 1</l>
<l>    NumEntries := |Values| / Dimension</l>
<l>    create_matrix (Dimension, NumEntries, Values, MatrixID)</l>
<l>    transpose_matrix_mod (MatrixID)</l>
<c>    * </c>
<l>else</l>
<c>    * Fehlerfall. Das war so nicht vorgesehen</c>
<c>    * ERROR DETECTED</c>
<l>    Result := 0</l>
<l>    Result := Result / Result</l>
<c>    * </c>
<l>endif</l>
<c>* </c>
<l>return ()</l>
</body>
<docu id="jsonToTuple">
<short lang="de_DE">Function to extract a matrix/array from a json string</short>
<parameters>
<parameter id="JsonString">
<default_type>string</default_type>
<description lang="de_DE">Json string containing a matrix/array</description>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="MatrixID">
<default_type>integer</default_type>
<description lang="de_DE">Halcon matrix</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>matrix</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="Values">
<default_type>real</default_type>
<description lang="de_DE">Tuple containing all values from the json string</description>
<multivalue>optional</multivalue>
<sem_type>real</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="nxLibGetPose">
<interface>
<ic>
<par name="Handle" base_type="ctrl" dimension="0"/>
<par name="ItemPath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Pose" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>*Read rotation data</c>
<l>get_framegrabber_param (Handle, ItemPath + '/Rotation/Angle', angle)</l>
<l>get_framegrabber_param (Handle, ItemPath + '/Rotation/Axis/\\0', axisX)</l>
<l>get_framegrabber_param (Handle, ItemPath + '/Rotation/Axis/\\1', axisY)</l>
<l>get_framegrabber_param (Handle, ItemPath + '/Rotation/Axis/\\2', axisZ)</l>
<c></c>
<c>*Read translation data</c>
<l>get_framegrabber_param (Handle, ItemPath + '/Translation/\\0', transX)</l>
<l>get_framegrabber_param (Handle, ItemPath + '/Translation/\\1', transY)</l>
<l>get_framegrabber_param (Handle, ItemPath + '/Translation/\\2', transZ)</l>
<c></c>
<c>*Make Halcon pose</c>
<l>axis_angle_to_quat(axisX,axisY,axisZ,angle,q)</l>
<l>quat_to_pose(q, p)</l>
<l>p[0] := transX</l>
<l>p[1] := transY</l>
<l>p[2] := transZ</l>
<l>Pose := p</l>
<c></c>
<l>return ()</l>
</body>
<docu id="nxLibGetPose">
<short lang="de_DE">Reads a given transformation node and converts the axis angle representation into a Halcon pose</short>
<parameters>
<parameter id="Handle">
<default_type>integer</default_type>
<description lang="de_DE">Framegrabber handle</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ItemPath">
<default_type>string</default_type>
<description lang="de_DE">Relative path to transformation item</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<description lang="de_DE">Halcon pose</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="nxLibGetRectifiedCameraSetup">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="CameraSetupModelID" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* Returns a CameraSetupModel for the given NxLib camera handle. </c>
<c>* Note that this CameraSetupModel can only be used on rectified images.</c>
<c></c>
<l>F := 0.008</l>
<c></c>
<l>get_framegrabber_param(AcqHandle, 'Sensor/Size/\\0', Width)</l>
<l>get_framegrabber_param(AcqHandle, 'Sensor/Size/\\1', Height)</l>
<c></c>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Left/Camera/\\0/\\0', Fx)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Left/Camera/\\1/\\1', Fy)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Left/Camera/\\2/\\0', Cx)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Left/Camera/\\2/\\1', Cy)</l>
<c></c>
<l>CamParamL := [F, 0, 0, 0, 0, 0, F/Fx, F/Fy, Cx, Cy, Width, Height]</l>
<c></c>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Right/Camera/\\0/\\0', Fx)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Right/Camera/\\1/\\1', Fy)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Right/Camera/\\2/\\0', Cx)</l>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Dynamic/Stereo/Right/Camera/\\2/\\1', Cy)</l>
<c></c>
<l>CamParamR := [F, 0, 0, 0, 0, 0, F/Fx, F/Fy, Cx, Cy, Width, Height]</l>
<c></c>
<l>get_framegrabber_param(AcqHandle, 'Calibration/Stereo/Baseline', Baseline)</l>
<c></c>
<l>PoseL := [0, 0, 0, 0, 0, 0, 0]</l>
<l>PoseR := [Baseline * 0.001, 0, 0, 0, 0, 0, 0]</l>
<c></c>
<l>create_camera_setup_model (2, CameraSetupModelID)</l>
<c></c>
<l>set_camera_setup_cam_param (CameraSetupModelID, 0, 'area_scan_polynomial', CamParamL, PoseL)</l>
<l>set_camera_setup_cam_param (CameraSetupModelID, 1, 'area_scan_polynomial', CamParamR, PoseR)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="nxLibGetRectifiedCameraSetup">
<short lang="de_DE">Returns a CameraSetupModel for the given NxLib camera handle. Note that this CameraSetupModel can only be used on the rectified images.</short>
<parameters>
<parameter id="AcqHandle">
<default_type>integer</default_type>
<description lang="de_DE">Framegrabber handle</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="CameraSetupModelID">
<default_type>integer</default_type>
<description lang="de_DE">Camera setup model</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>camera_setup_model</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
<procedure name="nxLibSetPose">
<interface>
<ic>
<par name="Handle" base_type="ctrl" dimension="0"/>
<par name="ItemPath" base_type="ctrl" dimension="0"/>
<par name="Pose" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>*Convert Halcon pose into axis angle representation</c>
<c>*Unfortunately pose_to_quat doesn't handle 'abg' poses correctly, so we need to convert to 'gba' first</c>
<l>convert_pose_type(Pose, 'Rp+T', 'gba', 'point', Pose2)</l>
<l>pose_to_quat(Pose2, q)</l>
<l>angle := 2*acos(q[0])</l>
<l>axis  := q[1:3]</l>
<l>axisNorm := sqrt(sum(axis*axis))</l>
<l>if (axisNorm &gt; 0)</l>
<l>    axis := axis/axisNorm</l>
<l>else</l>
<l>    axis := [1, 0, 0]</l>
<l>endif</l>
<l>out := '{'+\
         '"Rotation":{'+\
             '"Axis":['+axis[0]+','+axis[1]+','+axis[2]+'],'+\
             '"Angle":'+angle+'},'+\
         '"Translation":['+Pose2[0]+','+Pose2[1]+','+Pose2[2]+']'+\
       '}'</l>
<c>*Write rotation and translation data in a block!</c>
<c>*This is important to prevent renormalization of the axis while writing</c>
<l>set_framegrabber_param (Handle, ItemPath, ['apply', out])</l>
<c></c>
<l>return ()</l>
</body>
<docu id="nxLibSetPose">
<short lang="de_DE">Converts a Halcon pose into axis angle representation and writes it into the given transformation node</short>
<parameters>
<parameter id="Handle">
<default_type>integer</default_type>
<description lang="de_DE">Framegrabber handle</description>
<mixed_type>false</mixed_type>
<multivalue>false</multivalue>
<sem_type>framegrabber</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="ItemPath">
<default_type>string</default_type>
<description lang="de_DE">Relative path to transformation item</description>
<multivalue>false</multivalue>
<sem_type>string</sem_type>
<type_list>
<item>string</item>
</type_list>
</parameter>
<parameter id="Pose">
<default_type>real</default_type>
<description lang="de_DE">Halcon pose</description>
<multivalue>true</multivalue>
<sem_type>pose</sem_type>
<type_list>
<item>integer</item>
<item>real</item>
</type_list>
</parameter>
</parameters>
</docu>
</procedure>
</hdevelop>
